# Story 2.3: Advanced Filtering & Cross-Filtering

## Status
Draft

## Story
As a business user, I want global and cross-filters with advanced operators so that I can explore relationships across charts efficiently.

## Scope
- In-scope: Global filter state, cross-filter events, saved filter sets, perf caching, UI components.
- Out-of-scope: Row-level security (3.1) and access-based filtering (covered elsewhere).

## Acceptance Criteria (Given/When/Then)
1) Global Filters
- Given a dashboard with multiple charts
- When I apply a global filter (date/categorical/numeric/text)
- Then all eligible charts update consistently and show an active filter indicator

2) Cross-Filtering
- Given a chart supports selection
- When I click a bar/point/segment
- Then other charts apply the corresponding filter and UI indicates cross-filter origin

3) Advanced Operators
- Given filter builders
- When I choose operators (eq, ne, gt, lt, between, in, contains, regex) and AND/OR groups
- Then the generated predicate is valid and applied server-side

4) Saved Filter Sets
- Given I have created filters
- When I save as a named set
- Then I can later load and apply them in one action

5) Performance & Debounce
- Given rapid filter changes
- When I adjust sliders or type
- Then updates debounce (>=300ms) and use cached results where safe

6) UX & A11y
- Given a filter UI
- When using keyboard/screen readers
- Then all controls are operable and labeled

## API Specifications (Backend)
- Base: /api/v1/filters
- POST /evaluate { dashboardId, predicates[], options } -> { resultRefs | metrics }
- POST /filter-sets { name, dashboardId, predicates[] } -> { id }
- GET /filter-sets?dashboardId= -> [ { id, name, predicates[] } ]
- DELETE /filter-sets/:id
- Predicates schema: { field, op, value | values[] | range{min,max} }

## Data Model / Migrations
- filter_sets(id, tenant_id, dashboard_id, name, predicates jsonb, created_at, updated_at)
- filter_metrics(id, dashboard_id, predicate_hash, duration_ms, cache_hit, created_at)

## Architecture
- Frontend FilterService manages state, emits events; DashboardSlice integrates
- Server evaluates predicates close to data source; supports cache key by predicate_hash

## Security
- Validate field access; prevent injection (parameterized queries)
- Limit regex complexity to avoid ReDoS; max predicate depth

## Performance Targets
- Debounced updates render < 500ms for cached, < 1500ms uncached typical
- Cache TTL 60s; LRU max 100 entries per dashboard

## Observability
- Metrics: filter.evaluate.duration, cache.hit_rate, crossfilter.events
- Logs with predicate hashes, not raw values (PII safe)

## Rollout/Backout
- Feature flag per chart type enabling cross-filter; backout by disabling cross-filter only

## Risks & Mitigations
- R: Predicate explosions -> M: limit groups and depth, show warnings
- R: Inconsistent states -> M: single source of truth store

## UX/Design Notes
- Filter bar with chips; clear-all; builder with preview of affected row counts

## Testing Strategy
- Unit: predicate builder, debouncer, caching
- Integration: cross-chart event propagation
- E2E: apply/save/load filters, stress tests with rapid changes

## Tasks / Subtasks
1. Predicate schema and validation
2. Frontend filter components (AdvancedDateFilter, MultiSelect, NumericRange)
3. Cross-filter event bus and handlers
4. Backend evaluation API and caching
5. Saved sets CRUD
6. Tests and docs

## NFRs
- Security: safe predicates; size/time limits
- Reliability: fallback to server evaluation on client failures

## Definition of Done
- [ ] Global + cross-filter work end-to-end
- [ ] Saved sets persist and restore accurately
- [ ] Perf targets met; telemetry wired
- [ ] Tests >= 80%

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-05 | 2.0 | Regenerated with exhaustive spec | Bob |

## Dev Agent Record
(To be filled by Dev)

## QA Results
(To be filled by QA)

