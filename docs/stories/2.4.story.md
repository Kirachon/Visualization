# Story 2.4: Real-time Dashboard Updates

## Status
Draft

## Story
As an operations manager, I want dashboards to update live via WebSockets/streams so that I can monitor KPIs in real-time.

## Scope
- In-scope: WS transport, client, live bindings, Kafka ingest bridge, UI indicators, resiliency.
- Out-of-scope: Complex stream processing (see 4.2).

## Acceptance Criteria (Given/When/Then)
1) Live Transport
- Given an authenticated user
- When dashboard loads with live mode enabled
- Then a secure WebSocket (JWT cookie) connects and subscribes to topics per widget

2) Update Delivery
- Given new datapoints arrive
- When backend pushes updates
- Then charts update within 500ms and animate deltas

3) Resilience
- Given network disruption
- When WS drops
- Then client shows reconnecting, retries with backoff, and resumes subscriptions (server supports resume tokens)

4) Configurable Frequency
- Given a chart
- When I set refresh interval/manual or live
- Then the chart respects mode and shows status badge (Live/Manual/Every 30s)

5) Kafka Bridge
- Given external streams
- When Kafka messages arrive
- Then bridge normalizes to chart series format and forwards to subscribers with backpressure control

6) Security
- Given a multi-tenant system
- When subscribing
- Then users can only receive topics in their tenant; server enforces ACLs

## Backend APIs & Contracts
- WS endpoint: wss://.../api/ws (auth via cookie)
- Subscribe message: { type:"subscribe", widgetId, topic, resumeToken? }
- Update payload: { widgetId, ts, series: [...], meta }
- Resume: { type:"resume", token }
- REST fallback: GET /api/v1/dashboards/:id/updates?since=timestamp

## Services
- websocketService: connection/auth/subscribe/resume; per-tenant isolation
- realtimeDataService: widget topic registry, fanout, QoS
- kafkaConsumerService: consumes topics, transforms, backpressure (bounded queues)

## Security & Compliance
- JWT auth; per-tenant topic prefix; rate limits; message size caps; sanitize payloads; audit connects/subscribes

## Performance Targets
- Median push latency < 200ms; 95th < 500ms; handle 1000 concurrent clients per node

## Observability
- Metrics: ws.connections, msg.in/out rate, backlog size, reconnects, latency histograms
- Logs: connection lifecycle; anomalies

## Rollout/Backout
- Feature flag "liveDashboards" per tenant; backout by disabling flag

## Risks & Mitigations
- R: Message storms -> M: batching/coalescing, per-subscriber QoS
- R: Memory growth -> M: bounded queues, drop oldest strategy with metrics

## UX/Design
- Status pill: Live/Paused/Reconnecting; last updated timestamp; manual refresh icon

## Testing Strategy
- Unit: client reconnect logic; server fanout
- Integration: WS auth, subscribe/resume; Kafka bridge with docker-compose
- E2E: live updates across 3 widgets; simulate outages; verify UI state

## Tasks / Subtasks
1. WS server + auth + subscribe/resume
2. Client library with backoff and status
3. Kafka bridge consumer
4. Widget bindings and live indicators
5. Tests and docs

## NFRs
- Security: strict ACL; input validation; size/time limits
- Reliability: retries, backoff, resume tokens; health probes

## DoD
- [ ] Live updates end-to-end with metrics
- [ ] Reconnect and resume work reliably
- [ ] Kafka bridge functional
- [ ] Tests >= 80%

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-05 | 2.0 | Regenerated with exhaustive spec | Bob |

## Dev Agent Record
(To be filled by Dev)

## QA Results
(To be filled by QA)

