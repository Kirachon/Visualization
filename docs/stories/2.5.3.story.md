# Story 2.5.3 Materialized Views (MV): Auto-detect, Refresh Scheduler, Query Rewriter Integration

## Status
Done (implemented and verified)

## Summary
Introduce a first-class Materialized Views capability to reduce latency and load for repeated analytical queries. The system will:
- Detect candidate queries for MV (heuristics + optimizer signals)
- Maintain an MV Catalog (definitions, freshness, dependencies, stats)
- Provide manual MV management APIs (create/list/update/delete/refresh)
- Run a safe in-process refresh scheduler (feature-flagged)
- Integrate with the optimizer/query path to rewrite eligible queries to use fresh MVs
- Enforce strict safety guards (feature flags, freshness windows, semantic matching)

## Scope
- MVP supports MVs materialized as physical tables in the OLTP engine backing the data source.
- Candidate patterns: SELECT with GROUP BY/aggregates, time-bucket rollups, filtered star/snowflake fact aggregations.
- Query Rewriter: if request SQL is semantically equivalent (normalized AST, compatible predicates/projections) and MV is fresh, rewrite to use MV table.
- Refresh: manual trigger + periodic scheduler; full refresh MVP; incremental refresh deferred.
- Multi-tenant isolation respected across all operations.

Non-goals (this story):
- Cross-engine MVs (e.g., build in ClickHouse for OLTP sources)
- Incremental refresh, CDC, trigger-based maintenance
- Automatic storage/partition management beyond basic table creation

## Feature Flags (env)
- MV_ENABLE=false: Master switch; when false, no MV detection, rewrite, or scheduling occurs
- MV_AUTO_DETECT_ENABLE=false: Enable automatic candidate detection pipeline
- MV_REWRITE_ENABLE=false: Allow query rewrite to use a matching fresh MV
- MV_AUTO_REFRESH_ENABLE=false: Enable in-process periodic refresh scheduler
- MV_MAX_STALENESS_MS=600000: Max allowable staleness for rewrite eligibility (10m default)
- MV_SCHEDULER_INTERVAL_MS=60000: Refresh polling/dispatch interval (1m default)

## Architecture
1) MV Catalog (metadata, persisted)
   - Stores MV definitions, target table, normalized signature/hash, freshness TTL, last refresh status/time, usage stats, tenant, owner, enabled flags.
   - Tracks dependencies (base tables/views) to inform invalidation opportunities (advisory only in MVP).

2) Detection Pipeline (optional, gated)
   - Sources: perfService slow query logs + queryOptimizer recommendations.
   - Heuristics: GROUP BY with aggregates, high cardinality reductions, repeated filters/time windows, high cost/latency, high request frequency.
   - Produces suggested MV definitions (SELECT ...), with proposed primary key/projection.
   - Suggestions stored in Catalog as "proposed" until manually approved (API) in MVP.

3) Refresh Scheduler (in-process)
   - Periodic loop scans enabled MVs where now - last_refreshed_at > refresh_interval OR flagged for refresh.
   - Executes refresh (full rebuild in MVP) in a safe, serialized manner per MV and tenant.
   - Captures metrics + status, updates Catalog.

4) Query Rewriter Integration (optimizer pre-exec hook)
   - Parse/normalize incoming SQL to signature
   - Find candidate MV with compatible signature, predicate window containment, projection coverage, and within MV_MAX_STALENESS_MS
   - Rewrite SELECT to read from MV table with appropriate filters/projected columns
   - Attach metadata: mv.used=true, mv.id, mv.freshnessMs, reason when not used

5) Safety & Observability
   - All actions are feature-flagged, with conservative fallbacks
   - Expose MV metrics in perfService (counts: mvSuggested, mvRefreshSuccess/Failed, mvRewriteUsed/Bypassed)
   - Detailed audit logs for MV CRUD and refresh operations

## Data Model (MV Catalog)
- id (uuid)
- tenant_id (uuid)
- name (string, unique per tenant)
- definition_sql (text)  // canonical SELECT
- target_table (string)  // physical table name
- normalized_signature (string) // AST-based normalized hash/signature
- freshness_ttl_ms (int)
- refresh_interval_ms (int)
- last_refreshed_at (timestamptz, nullable)
- last_refresh_status (enum: success|failed|never)
- enabled (boolean)
- proposed (boolean) // from auto-detection and pending manual approval
- created_at, updated_at
- usage_count_24h (int) // advisory, for prioritization
- dependencies (jsonb) // list of base tables, optional

## API (MVP)
- POST /api/v1/mv
  - body: { name, definitionSql, targetTable?, freshnessTtlMs, refreshIntervalMs, enabled }
  - creates catalog entry; creates physical table if MV_ENABLE and enabled; returns MV record

- GET /api/v1/mv
  - list catalog entries (filters: enabled, proposed)

- GET /api/v1/mv/:id
  - fetch by id (includes last refresh info, dependencies, normalized signature)

- PATCH /api/v1/mv/:id
  - update properties (enabled, intervals, definitionSql with revalidation, etc.)

- DELETE /api/v1/mv/:id
  - delete from catalog, optionally drop physical table if present and safe

- POST /api/v1/mv/:id/refresh
  - manual refresh; returns status and updated timestamps

- GET /api/v1/mv/suggestions (optional in MVP, gated by MV_AUTO_DETECT_ENABLE)
  - list proposed MVs

Note: AuthN/Z follows existing RBAC; only admin/data-engineer roles permitted for MV management.

## Acceptance Criteria
- MV catalog persists definitions with tenant scoping and supports CRUD + manual refresh
- In-process refresh scheduler (feature-flagged) refreshes eligible MVs and updates status
- Query rewriter (feature-flagged) routes eligible queries to fresh MV with correct results
- Optimizer metadata on query responses includes mv usage or bypass reasons
- Auto-detection produces proposed MVs from recorded workload (heuristic-based), disabled by default
- Comprehensive tests: unit (+detection, catalog, rewriter), integration (APIs, rewrite, scheduler with fake timers)
- Builds pass (api, web)

## Risks & Mitigations
- Staleness / correctness risk: enforce freshness TTL, validate semantic compatibility, default to bypass
- Refresh cost spikes: serialize per MV; rate-limit; stagger schedule; size thresholds
- Rewrite false positives: strict signature match + predicate containment, projection coverage check
- Tenancy leakage: enforce tenant_id throughout; rewrite only to tenant-owned MV tables
- Storage growth: quotas and alerts (deferred), soft cap warnings in logs
- Crash during refresh: transactional table swap (CREATE TABLE temp, INSERT SELECT; then swap) in future; MVP uses TRUNCATE+INSERT with caution

## Verification Strategy
- Unit tests:
  - Signature/normalization hashing stable for semantically identical queries
  - Catalog service CRUD and validation
  - Rewriter eligibility checks (staleness, predicates, projection)
  - Detection heuristics yield expected candidates for synthetic workloads
- Integration tests:
  - MV management APIs (create/list/get/update/delete/refresh)
  - Query path uses MV when enabled, fresh, and compatible (attach mv metadata)
  - Scheduler with jest fake timers executes refresh cycle and updates catalog
- Regression:
  - Ensure no change when MV features disabled
  - Existing perf and query tests continue to pass
- Build:
  - `npm run build` (api, web)

## QA Evidence
- MV test suites: 25 tests passing (17 unit, 8 integration)
  - Files: services/mvCatalogService.test.ts (+ extras), mvRewriteService.test.ts (+ extras), mvSchedulerService.test.ts, mvDetectionService.test.ts, controllers/mvController.test.ts, controllers/mv404.integration.test.ts, controllers/mvRewrite.path.test.ts, integration/mv.rewrite.integration.test.ts, integration/mv.metadata.noeligible.test.ts, integration/mv.list.filters.test.ts
- Targeted regression suites: Query Optimizer unit tests (10) and related integration tests passing in isolation; full E2E tests intentionally excluded (require external DB)
- Builds:
  - apps/api: PASS (tsc)
  - apps/web: PASS (tsc + vite)

## Notes
- Feature flags default to disabled; MV components are inert unless explicitly enabled
- E2E suites rely on external Postgres and are out of scope for this story's gated verification

## High-level Implementation Plan (no code yet)
1) MV Catalog
   - DB schema migration (catalog table); CatalogService with validation and signature computation via AST/normalizer
   - RBAC-protected controller + routes for manual MV management

2) Refresh Scheduler (MVP)
   - In-process loop (setInterval) gated by MV_AUTO_REFRESH_ENABLE; per-tenant queue with serialization per MV
   - Refresh implementation (full rebuild) + status/metrics

3) Query Rewriter Integration
   - Extend optimizer pre-exec hook: compute normalized signature; lookup eligible MV; recompose SELECT from MV table; attach metadata

4) Auto-detection
   - Build suggestion generator consuming perfService slow queries and optimizer recommendations; store as proposed entries

5) Observability
   - perfService counters; request metadata annotations; logs + audit entries

6) Hardening & Docs
   - Failure modes, staleness handling, bypass reasons; documentation and examples

## Deferrals
- Incremental refresh and CDC-based maintenance
- Cross-engine MVs (e.g., OLTP>ClickHouse)
- Partition management and table swap refresh strategy
- UI for MV suggestion review and management (API-first)
- Quotas and automated storage lifecycle

## Rollout
- Phase 0: Disabled by default in all envs
- Phase 1: Enable MV catalog + manual refresh in staging; no rewrite
- Phase 2: Enable scheduler; monitor metrics
- Phase 3: Enable rewrite for a small subset (allowlist); monitor correctness and performance
- Phase 4: Evaluate auto-detection pipeline in propose-only mode

