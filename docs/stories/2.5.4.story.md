# Story 2.5.4 â€” Performance Dashboards (Frontend)

Status: Done
Owner: Backend + Web
Feature Flags: none (consumes existing APIs)

## Scope
Frontend visualization for:
- Slow queries (last N window) via GET /api/v1/perf/queries/slow?since
- Cache stats via GET /api/v1/perf/cache/stats
- Engine split (OLAP vs OLTP) via GET /api/v1/perf/engine/split?since

## Implementation
- Backend
  - Extended perfService with in-memory engine usage events and `engineSplitSince(sinceMs)`
  - queryController now records engineUsed on both cached and executed responses
  - New endpoint: GET /api/v1/perf/engine/split
- Web
  - New page: PerformanceDashboard at /performance
  - Sidebar navigation entry "Performance"
  - Service: apps/web/src/services/perfService.ts

## Acceptance Criteria
- User can navigate to /performance and see:
  - Cache hit rate, item count and size
  - Engine split with OLAP percentage and counts
  - Table of top slow queries (hash, duration, time)
- Data auto-refreshes periodically (10s)
- Works without external infra (in-memory stats ok)

## QA Evidence
- API integration tests:
  - perf.engine.split endpoint returns counts after simulated records
- Web unit test:
  - PerformanceDashboard renders and shows expected sections
- Targeted suite (API + WS + RBAC + cache + timeouts + OLAP path) all passing
- Builds pass for apps/api and apps/web

## Deferrals
- Persisted/aggregated metrics store (Prometheus or DB)
- Detailed query introspection and hash lookup UI
- Time-range selector and trend charts

## Notes
- Engine split is approximate over an in-memory window; adequate for initial dashboarding. Can later switch to durable metrics.

