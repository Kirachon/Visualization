# Story 3.1: Role-Based Access Control (RBAC)

## Status
Draft

## Story
As a security administrator, I want granular RBAC with row/column/resource permissions so that sensitive data is enforced per policy.

## Scope
- In-scope: Roles, permissions, row-level filters, column masking, audit, validation tools.
- Out-of-scope: SSO integration (3.2).

## Acceptance Criteria (Given/When/Then)
1) Roles & Permissions
- Given 5 roles (Viewer, Analyst, Designer, Admin, SuperAdmin)
- When assigned to users
- Then permissions apply: resource CRUD, data-query rights, share rights, admin ops

2) Row-Level Security (RLS)
- Given user attributes (tenant, department, region)
- When querying data
- Then predicates are automatically applied server-side without client bypass

3) Column Masking
- Given sensitive columns
- When accessed by roles below clearance
- Then masking strategies (full/partial/hash) apply

4) Resource Permissions
- Given dashboards and data sources
- When permissions are configured
- Then access is enforced at resource level; sharing respects RBAC

5) Escalation & Approval
- Given temporary access request
- When approved by Admin
- Then time-bound permissions are granted and logged

6) Audit Logging
- Given any access attempt (success/failure)
- When it occurs
- Then audit log records who/what/when/where (IP/UA) with tamper protection

## Data Model / Migrations
- roles(id, name, inherits_from[], description)
- permissions(id, action, resource, condition?)
- role_permissions(role_id, permission_id)
- user_roles(user_id, role_id)
- rls_policies(id, name, predicate_sql, applies_to)
- column_masks(id, table, column, strategy, rule)
- access_audit(id, user_id, action, resource_type, resource_id, allowed, ip, ua, at, hash_chain)

## APIs
- /api/v1/rbac/roles [GET/POST/PUT/DELETE]
- /api/v1/rbac/permissions [GET/POST]
- /api/v1/rbac/assign [POST]
- /api/v1/rbac/escalations [POST/PUT]
- /api/v1/audit [GET]

## Enforcement Architecture
- Middleware injects tenant/user claims
- QueryService composes WHERE with RLS predicate
- Column masking at projection step
- Resource guard checks permission matrix

## Security
- Least privilege default; deny-by-default
- Tamper-proof audit (hash chain; offsite replication)
- Admin actions require MFA (if enabled)

## Observability
- Metrics: rls.applied, mask.applied, access.denied, escalation.count
- Logs: structured with tenant_id, user_id, resource

## Performance
- RLS overhead < 100ms; predicate caching per table+role

## Rollout/Backout
- Feature flag per enforcement stage (RLS, masking)

## Risks & Mitigations
- R: Predicate errors -> M: policy tests + dry-run validator
- R: Overmasking -> M: preview tools and audits

## UX/Design
- RoleManager page; policy editors with preview (sample row count)

## Testing Strategy
- Unit: predicate builder, mask functions
- Integration: enforce in queries; resource guards
- E2E: role scenarios across dashboards and data

## Tasks / Subtasks
1. Data model and migrations
2. Policy evaluation engine (RLS + masking)
3. Resource permission middleware
4. Escalation workflow + approvals
5. Audit service with hash chain
6. RoleManager UI
7. Test suites + docs

## NFRs
- Security: deny-by-default; audit integrity
- Reliability: policy cache with invalidation; fallback safe deny

## DoD
- [ ] Policies enforce correctly across endpoints
- [ ] Audit trails verifiable
- [ ] Tests >= 85%

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-05 | 2.0 | Regenerated with exhaustive spec | Bob |

## Dev Agent Record
(To be filled by Dev)

## QA Results
(To be filled by QA)

